<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F04%2F02%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言想要分析下源码是好事，但是如何进行分析呢？以我为例，我进行源码分析的过程如下几步： 找到类：利用IDEA找到所需要分析的类（这里就是ArrayList） 新建类：新建一个类，命名为ArrayList,将源码拷贝到该类中。因为我们在分析的过程中肯定是需要对代码进行注释和调试的，而对jdk的源码，我们没法儿在里面直接写注释以及调试的。 按照上面的方法将新建AbstractList类，并将源码拷贝过来，这是由于ArrayList中要用到AbstractList类中的变量，如果不拷贝过来就会报错。 修改类：我们刚拷贝过来的源码，肯定会报错的。报错原因比如：包名不匹配、继承的类中权限问题，因此我们需要对源码进行修改 查看代码 + 测试案例 + 断点调试：前面准备好了，就到分析的过程了。分析，不仅仅是简单的看下代码，我们需要仔细思考，且辅以相应的测试案例，甚至于进行断点跟踪查看运行过程。下面我们就对jdk1.8的源码进行分析。 ArrayList简介ArrayList概述 ArrayList是可以动态增加和缩减的，踏实数组实现的list类。 该类封装了一个动态再分配的Object[]数组，每一个类对象都有一个capacity属性，表示他们所封装的数组的长度，当向ArrayList中添加数据的时候，capacity会自动增长，如果想ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capacity，可以减少增加重分配的次数提高性能。 ArrayList的用法和Vector向类似，但是Vector是一个较老的集合，具有很多缺点，不建议使用。另外，ArrayList和Vector的区别是：ArrayList是线程不安全的，当多条线程访问同一个ArrayList集合时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。 ArrayList的数据结构分析一个类的时候，数据结构往往是它的灵魂所在，理解底层的数据结构其实就是理解该类的思路。ArrayList的数据结构是：PS：底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对ArrayList类的实例的所有的操作底层都是基于数组的。 ArrayList源码分析继承结构和层次关系分析： 为什么要先继承AbstractList，而让AbstractList先实现List？而不是让ArrayList直接实现List？这里是有一个思想，接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来，先一起实现了，减少重复代码。所以一般看到一个类上面还有一个抽象类，应该就是这个作用。 ArrayList实现了哪些接口？ List接口：我们会出现这样一个疑问，在查看了ArrayList的父类AbstractList也实现了List接口，那为什么子类ArrayList还是去实现一遍呢？开发这个collection 的作者Josh说：这其实是一个mistake，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。 RandomAccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取，有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如arrayList。而没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了让我们知道我们用什么样的方式去获取数据性能更好。 Cloneable接口：实现了该接口，就可以使用Object.Clone()方法了。 Serializable接口：实现该序列化接口，表明该类可以被序列化，什么是序列化？简单的说，就是能够从类变成字节流传输，然后还能从字节流变成原来的类。类中的属性123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 版本号 private static final long serialVersionUID = 8683452581122892189L; // 缺省容量 private static final int DEFAULT_CAPACITY = 10; // 空对象数组 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; // 缺省空对象数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; // 元素数组 transient Object[] elementData; // 实际元素大小，默认为0 private int size; // 最大数组容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;&#125; 构造方法ArrayList有三个构造方法： 无参构造方法 12345678/*** 这里就说明了默认会给10的大小，所以说一开始arrayList的容量是10.*///ArrayList中储存数据的其实就是一个数组，这个数组就是elementData，在123行定义的 private transient Object[] elementData; public ArrayList() &#123; super(); //调用父类中的无参构造方法，父类中的是个空的构造方法 this.elementData = EMPTY_ELEMENTDATA;//EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。&#125; 有参构造方法(一) 1234567public ArrayList(int initialCapacity) &#123; super(); //父类中空的构造方法 if (initialCapacity &lt; 0)&#123; //判断如果自定义大小的容量小于0，则报下面这个非法数据异常 throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity); this.elementData = new Object[initialCapacity]; //将自定义的容量大小当成初始化elementData的大小 &#125;&#125; 有参构造方法(二) 123456789101112//这个构造方法不常用，举个例子就能明白什么意思/* Strudent exends Person ArrayList&lt;Person&gt;、 Person这里就是泛型 我还有一个Collection&lt;Student&gt;、由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection&lt;Student&gt;转换为ArrayList&lt;Sudent&gt;这就是这个构造方法的作用 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); //转换为数组 size = elementData.length; //数组中的数据个数 if (elementData.getClass() != Object[].class) //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。 elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 总结：arrayList的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数组，在其中就叫elementData。 核心方法 add()方法（有四个） boolean add(E)//默认直接在末尾添加元素12345678910/*** 添加一个特定的元素到list的末尾。*/public boolean add(E e) &#123; //确定内部容量是否够了，size是数组中数据的个数，因为要添加一个元素，所以size+1，先判断size+1的这个个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了。 ensureCapacityInternal(size + 1); // Increments modCount!! //在数据中正确的位置上放上元素e，并且size++ elementData[size++] = e; return true;&#125; 分析：ensureCapacityInternal(xxx); 确定内部容量的方法 12345678private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; //看，判断初始化的elementData是不是空的数组，也就是没有长度 //因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存放不了，所以就将minCapacity变成10，也就是默认大小，但是带这里，还没有真正的初始化这个elementData的大小。 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否够用 ensureExplicitCapacity(minCapacity);&#125; ensureExplicitCapacity(xxx);123456789101112private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;/*minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用，不够用那么就要增加elementData的length。这里有的同学就会模糊minCapacity到底是什么呢，这里给你们分析一下第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量ensureCapacityInternal)就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，还没有改变elementData的大小。第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。*/ if (minCapacity - elementData.length &gt; 0) //arrayList能自动扩展大小的关键方法就在这里了 grow(minCapacity);&#125; grow(xxx);arrayList核心的方法，能扩展数组大小的真正秘密。12345678910private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //将扩充前的elementData大小给oldCapacity int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//newCapacity就是1.5倍的oldCapacity if (newCapacity - minCapacity &lt; 0)//这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity newCapacity = hugeCapacity(minCapacity); //新的容量大小已经确定好了，就copy数组，改变容量大小咯。 elementData = Arrays.copyOf(elementData, newCapacity); &#125; hugeCapacity();12345678//这个就是上面用到的方法，很简单，就是用来赋最大值。 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将MAX_ARRAY_SIZE返回。因为maxCapacity是三倍的minCapacity，可能扩充的太大了，就用minCapacity来判断了。 //Integer.MAX_VALUE:2147483647 MAX_ARRAY_SIZE：2147483639 也就是说最大也就能给到第一个数值。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :MAX_ARRAY_SIZE;&#125; void add(int，E)；在特定位置添加元素，也就是插入元素12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index也就是插入的位置是否合理。 //跟上面的分析一样，具体看上面 ensureCapacityInternal(size + 1); //这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位， System.arraycopy(elementData, index, elementData, index + 1,size - index); //在目标位置上存放元素 elementData[index] = element; size++;//size增加1&#125; rangeCheckForAdd(index)1234private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) //插入的位置肯定不能大于size 和小于0,如果是，就报这个越界异常 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; System.arraycopy(…)：就是将elementData在插入位置后的所有元素往后面移一位。 删除方法1: remove(int)：通过删除指定位置上的元素12345678910111213public E remove(int index) &#123; rangeCheck(index);//检查index的合理性 modCount++;//这个作用很多，比如用来检测快速失败的一种标志。 E oldValue = elementData(index);//通过索引直接找到该元素 int numMoved = size - index - 1;//计算要移动的位数。 if (numMoved &gt; 0) //这个方法也已经解释过了，就是用来移动元素的。 System.arraycopy(elementData, index+1, elementData, index,numMoved); //将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。 elementData[--size] = null; // clear to let GC do its work //返回删除的元素。 return oldValue;&#125; clear()：将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear。1234567public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 总结：remove函数用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单位，并且会把数组最后一个元素设置为null，这样是为了方便之后将整个数组不被使用时，会被GC，可以作为小的技巧使用。 set()方法12345678910public E set(int index, E element) &#123; // 检验索引是否合法 rangeCheck(index); // 旧值 E oldValue = elementData(index); // 赋新值 elementData[index] = element; // 返回旧值 return oldValue;&#125; PS:设定指定下标索引的元素值 indexOf()方法1234567891011121314// 从首开始查找数组里面是否存在指定元素public int indexOf(Object o) &#123; if (o == null) &#123; // 查找的元素为空 for (int i = 0; i &lt; size; i++) // 遍历数组，找到第一个为空的元素，返回下标 if (elementData[i]==null) return i; &#125; else &#123; // 查找的元素不为空 for (int i = 0; i &lt; size; i++) // 遍历数组，找到第一个和指定元素相等的元素，返回下标 if (o.equals(elementData[i])) return i; &#125; // 没有找到，返回空 return -1;&#125; PS:从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找 get()方法12345public E get(int index) &#123; // 检验索引是否合法 rangeCheck(index); return elementData(index);&#125; PS:get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0），值得注意的是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下：123E elementData(int index) &#123; return (E) elementData[index];&#125; PS:返回的值都经过了向下转型（Object -&gt; E），这些是对我们应用程序屏蔽的小细节。 总结 arrayList可以存放null。 arrayList本质上就是一个elementData数组。 arrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。 arrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素。 arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果 arrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim简明教程]]></title>
    <url>%2F2018%2F03%2F28%2Fvim%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vim 是 Linux 系统上的最著名的文本/代码编辑器，也是早年的 Vi 编辑器的加强版， 而 gvim 则是其 Windows 版。它的最大特色是完全使用键盘命令进行编辑，脱离了鼠标操作虽然使得入门变得困难， 但上手之后键盘流的各种巧妙组合操作却能带来极为大幅的效率提升。 因此 vim 和现代的编辑器（如 Sublime Text）有着非常巨大的差异，而且入门学习曲线陡峭， 需要记住很多按键组合和命令，如今被看作是高手、Geek们专用的编辑器。尽管 vim 已经是古董级的软件， 但还是有无数新人迎着困难去学习使用，可见其经典与受欢迎程度。另外，由于 vim 的可配置性非常强， 各种插件、语法高亮配色方案等多不胜数，无论作为代码编辑器或是文稿撰写工具都非常给力。 安装以ubuntu为例：1sudo apt-get install vim 配置vim本身能够满足开发人员的很多需求，但是它的扩展性也是极强的，并且已经有一些杀手级的扩展，可以让vim有变成ide的能力，所以，你所需要的第一件东西就是一个好用的扩展管理器。 vim有多个扩展管理器，但是我们强烈推荐vundle。 我们先安装Vundle:1git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim 该命令下载的Vundle插件管理器，并将它放置在你的vim编辑器bundles文件夹中。现在，你可以通过.vimrc配置文件来管理所有扩展了。 我在这里有一个比较优化的配置，将vim打造成一个IDE，编辑~/.vimrc,输入如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151"vundleset nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'"git interfacePlugin 'tpope/vim-fugitive'"filesystemPlugin 'scrooloose/nerdtree'Plugin 'jistr/vim-nerdtree-tabs'Plugin 'kien/ctrlp.vim'"html" isnowfy only compatible with python not python3Plugin 'isnowfy/python-vim-instant-markdown'Plugin 'jtratner/vim-flavored-markdown'Plugin 'suan/vim-instant-markdown'Plugin 'nelstrom/vim-markdown-preview'"python sytax checkerPlugin 'nvie/vim-flake8'Plugin 'vim-scripts/Pydiction'Plugin 'vim-scripts/indentpython.vim'Plugin 'scrooloose/syntastic'"auto-completion stuff"Plugin 'klen/python-mode'Plugin 'Valloric/YouCompleteMe'Plugin 'klen/rope-vim'"Plugin 'davidhalter/jedi-vim'Plugin 'ervandew/supertab'""code foldingPlugin 'tmhedberg/SimpylFold'"Colors!!!Plugin 'altercation/vim-colors-solarized'Plugin 'jnurmine/Zenburn'call vundle#end()filetype plugin indent on " enables filetype detectionlet g:SimpylFold_docstring_preview = 1"autocompletelet g:ycm_autoclose_preview_window_after_completion=1"custom keyslet mapleader=" "map &lt;leader&gt;g :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;"call togglebg#map("&lt;F5&gt;")"colorscheme zenburn"set guifont=Monaco:h14let NERDTreeIgnore=['\.pyc$', '\~$'] "ignore files in NERDTree"I don't like swap filesset noswapfile"turn on numberingset nu"python with virtualenv supportpy &lt;&lt; EOFimport os.pathimport sysimport vimif 'VIRTUA_ENV' in os.environ: project_base_dir = os.environ['VIRTUAL_ENV'] sys.path.insert(0, project_base_dir) activate_this = os.path.join(project_base_dir,'bin/activate_this.py') execfile(activate_this, dict(__file__=activate_this))EOF"it would be nice to set tag files by the active virtualenv here":set tags=~/mytags "tags for ctags and taglist"omnicompleteautocmd FileType python set omnifunc=pythoncomplete#Complete"------------Start Python PEP 8 stuff----------------" Number of spaces that a pre-existing tab is equal to.au BufRead,BufNewFile *py,*pyw,*.c,*.h set tabstop=4"spaces for indentsau BufRead,BufNewFile *.py,*pyw set shiftwidth=4au BufRead,BufNewFile *.py,*.pyw set expandtabau BufRead,BufNewFile *.py set softtabstop=4" Use the below highlight group when displaying bad whitespace is desired.highlight BadWhitespace ctermbg=red guibg=red" Display tabs at the beginning of a line in Python mode as bad.au BufRead,BufNewFile *.py,*.pyw match BadWhitespace /^\t\+/" Make trailing whitespace be flagged as bad.au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/" Wrap text after a certain number of charactersau BufRead,BufNewFile *.py,*.pyw, set textwidth=100" Use UNIX (\n) line endings.au BufNewFile *.py,*.pyw,*.c,*.h set fileformat=unix" Set the default file encoding to UTF-8:set encoding=utf-8" For full syntax highlighting:let python_highlight_all=1syntax on" Keep indentation level from previous line:autocmd FileType python set autoindent" make backspaces more powerfullset backspace=indent,eol,start"Folding based on indentation:autocmd FileType python set foldmethod=indent"use space to open foldsnnoremap &lt;space&gt; za"----------Stop python PEP 8 stuff--------------"js stuff"autocmd FileType javascript setlocal shiftwidth=2 tabstop=2syntax on "语法高亮显示。set encoding=utf-8set hlsearch "高亮度反白set backspace=2 "可以用Backspace键删除set ts=4 "tab键等于4个空格set expandtab "tab键自动变空格set tabstop=4set softtabstop=4set autoindent "自动缩进set pastetoggle=&lt;F9&gt; "插入模式粘贴按F9取消自动缩进set ruler "可显示最后一行的状态set showmode "左下角那一行的状态set nu "可以在每一行的最前面显示行号啦！set bg=dark "显示不同的底色色调"set cursorline "光标所在行一横线set laststatus=2 "显示当前编辑文件名set showcmdset magicset lazyredrawset history=100 "历史记录条数set hlsearch "高亮显示搜索结果set incsearch "增量搜索，每次输入一个字母都自动搜"choose and replacevnoremap ,s y:%s/&lt;C-R&gt;=escape(@", '\\/.*$^~[]')&lt;CR&gt;/ PS:把配置写进去后，要在vim里面执行:PluginInstall命令来让Vundle自动帮你安装所有插件。 问题记录出现过问题”ouCompleteMe unavaliable:No module named ycmd” 解决办法：123cd ~/.vim/bundle/YouCompleteMegit pullgit submodule update --init --recursive 但是在执行过程中报错：The remote end hung up unexpectedly,这是因为网络不稳定，要下载的东西很多试几次，耐心一点就可以了。 The ycmd server SHUT DOWN (restart with ‘YcmRestartServer’)YCM需要手动变异才行，到.vim/bundle/YouCompleteMe下跑1./install.sh --clang-completer 此过程速度较慢，请耐心等待下买呢是我配置完成过后的vim： 入门vim 有三种模式： 一般模式：在linux终端输入”vim文件名”就进入了一般模式，但不能输入文字。 编辑模式：在一般模式下按i就会进入编辑模式，此时就可以写文字了，按ESC可以回退到一般模式。 命令模式： 在一般模式下按:就会进入命令模式，左下角会有一个冒号出现，此时可以敲入命令并执行。当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作： 启动vim后，vim在normal模式下。 让我们进入insert模式，请按i。（vim左下角有一个insert字样，表示你可以输入了） 此时，你可以输入文本了吗，就像你用记事本一样。 如果你想返回normal模式，请按ESC键现在，你知道如果在insert和normal模式下切换了。下面是一些命令，可以让你在normal模式下幸存下来：12345i -&gt; Insert模式，按ESC回到Normal模式。x -&gt; 删除当前光标所在的一个字符。:wq -&gt; 存盘 + 退出（w:存盘，q：退出）dd -&gt; 删除当前行，并把当前行存到剪切板里。p -&gt; 粘贴剪切板 推荐12hjkl(强烈推荐使用这几个键移动光标，但不必须) 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。:help &lt;command&gt; 显示相关命令的帮助。 进阶1现在是时候学习一些更多的命令了，下面是我的建议： 各种插入模式1234a → 在光标后插入o → 在当前行后插入一个新行O → 在当前行前插入一个新行cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标12340 → 数字零，到行头$ → 到本行行尾g_ → 到本行最后一个不是blank字符的位置。/pattern → 搜索 pattern 的字符串 拷贝/粘贴(p/P都可以，p是表示在当前位置之后，P表示在当前位置之前)12P → 粘贴yy → 拷贝当前行当行于 ddP Undo/Redo12u → undo&lt;C-r&gt; → redo 打开/保存/退出/改变文件(Buffer)123456:e &lt;path/to/file&gt; → 打开一个文件:w → 存盘:saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt;:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车):q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么说ArrayList线程不安全]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[概要介绍所谓线程安全，指多个线程同时操作同一个对象的时候，采用了加锁机制，当第一个线程在操作这个对象的时候，后面将要操作该对象的线程都得等第一个对象操作完成再执行，这样就能保证数据的完整性。 举例：List接口下面有两个，一个是ArrayList,一个是Vector。从源码的角度来分析，因为Vector的方法前加了，synchronized 关键字，也就是同步的意思，sun公司希望Vector是线程安全的，而希望arraylist是高效的，缺点就是另外的优点。 说下原理（百度的，很好理解）： 一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成： 在Item[size]的位置存放该元素; 增大size的值。在单线程运行的情况下，如果size=0,添加一个元素后，此元素位置在0，size=1;而如果是多线程的情况下；比如有两个线程，线程A先将元素存放在位置0，但是此时CPU的调度线程A暂停，线程B就有了运行的机会，线程B向此ArrayList中添加元素，此时size依然等于0，(我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1),所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。下面我们写段代码来验证123456789101112131415161718192021222324252627282930final List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0;i &lt; 10000;i++)&#123; list.add(i);&#125;System.out.println("第一次添加完成后list的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.remove(0); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("移除完成后List的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.add(j*10); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("第二次添加完成后List的数量："+list.size()); 输出的结果是：123第一次添加完成后list的数量：10000移除完成后List的数量：393第二次添加完成后List的数量：9319 而我们期望的结果是：123第一次添加完成后list的数量：10000移除完成后List的数量：0第二次添加完成后List的数量：10000 这就是因为ArrayList没有加同步锁导致的，下面再来一段Vector的代码：123456789101112131415161718192021222324252627282930final List&lt;Integer&gt; list = new Vector&lt;&gt;();for (int i = 0;i &lt; 10000;i++)&#123; list.add(i);&#125;System.out.println("第一次添加完成后list的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.remove(0); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("移除完成后List的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.add(j*10); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("第二次添加完成后List的数量："+list.size()); 输出结果：123第一次添加完成后list的数量：10000移除完成后List的数量：0第二次添加完成后List的数量：10000]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[聊聊Web会话管理]]></title>
    <url>%2F2018%2F03%2F26%2F%E8%81%8A%E8%81%8AWeb%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Web刚刚兴起的时候，服务器只提供一些简单的HTML页面，用户打开网址去浏览。并不需要记住每次请求是谁发来的，每次请求对于服务器来讲都是全新的。既然是浏览，服务器为什么要记住谁在这一段时间里浏览了什么呢？但是好日子没维持多久，很快大家都不满足于静态的HTML页面了，交互式的web应用兴起，尤其是论坛，在线购物等网站。必须管理会话，必须记住那些人登陆系统，哪些人在购物车放入商品，也就是说必须要把每个人区分开。由于HTTP协议的无状态特性，必须加点儿小手段才能管理会话。本文总结了3种常见的实现web应用会话管理的方式： 基于server端session的管理方式。 基于cookie的管理方式。 基于token的管理方式。session和cookie在讲解着三种方式之前，先科普一下几个知识。 由于http是无状态的协议，所以服务端需要记录用户的登陆状态时，就需要某种机制来识别具体的用户，这个机制就是session，session是保存在服务端的，有一个唯一标识。在大型的网站，一般会有专门的Session服务器集群，这个时候 Session 信息都是放在内存的。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。 实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端， 需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。 有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪， 即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？ 这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。 这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下： session 在服务器端，cookie 在客户端（浏览器） session 默认被存在在服务器的一个文件里（不是内存） session 的运行依赖 session id，而 session id 是存在cookie中的，也就是说，如果浏览器禁用了cookie， 同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） session 可以放在 文件、数据库、或内存中都可以。 用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id基于服务端的session在早期web应用中，通常使用服务端session来管理用户的会话。 服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。 服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。 服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候， 就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。 session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。 但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。 session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证， 才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。 当用户主动退出的时候，会把它的session对象里的登录凭证清掉。 所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。可简单使用流程图描述如下：主流的web开发平台都原生支持这种会话管理的方式，而且开发起来很简单。它还有一个比较大的优点就是安全性好， 因为在浏览器端与服务器端保持会话状态的媒介始终只是一个sessionid串，只要这个串够随机，攻击者就不能轻易冒充他人的sessionid进行操作； 除非通过CSRF或http劫持的方式，才有可能冒充别人进行操作；即使冒充成功，也必须被冒充的用户session里面包含有效的登录凭证才行。但是这种方式也有几个问题需要解决： 这种方式将会话信息存储在web服务器里面，所以在用户同时在线量比较多时，这些会话信息会占据比较多的内存； 当应用采用集群部署的时候，会遇到多台web服务器之间如何做session共享的问题。因为session是由单个服务器创建的， 但是处理用户请求的服务器不一定是那个创建session的服务器，这样他就拿不到之前已经放入到session中的登录凭证之类的信息了； 多个应用要共享session时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好cookie跨域的处理。针对问题1和问题2，我见过的解决方案是采用redis/memcached这种中间服务器来管理session的增删改查， 一来减轻web服务器的负担，二来解决不同web服务器共享session的问题。针对问题3，由于服务端的session依赖cookie来传递sessionid，所以在实际项目中，只要解决各个项目里面如何实现sessionid的cookie跨域访问即可， 这个是可以实现的，就是比较麻烦，前后端有可能都要做处理。如果在一些小型的web应用中使用，可以不用考虑上面三个问题，所以很适合这种方式。基于cookie由于前一种方式会增加服务器的负担和架构的复杂性，所以后来就有人想出直接把用户的登录凭证直接存到客户端的方案， 当用户登录成功之后，把登录凭证写到cookie里面，并给cookie设置有效期，后续请求直接验证存有登录凭证的cookie是否存在以及凭证是否有效， 即可判断用户的登录状态。使用它来实现会话管理的整体流程如下： 用户发起登录请求，服务端根据传入的用户密码之类的身份信息，验证用户是否满足登录条件，如果满足，就根据用户信息创建一个登录凭证， 这个登录凭证简单来说就是一个对象，最简单的形式可以只包含用户id，凭证创建时间和过期时间三个值。 服务端把上一步创建好的登录凭证，先对它做数字签名，然后再用对称加密算法做加密处理，将签名、加密后的字串，写入cookie。 cookie的名字必须固定（如ticket），因为后面再获取的时候，还得根据这个名字来获取cookie值。 这一步添加数字签名的目的是防止登录凭证里的信息被篡改，因为一旦信息被篡改，那么下一步做签名验证的时候肯定会失败。 做加密的目的，是防止cookie被别人截取的时候，无法轻易读到其中的用户信息。 用户登录后发起后续请求，服务端根据上一步存登录凭证的cookie名字，获取到相关的cookie值。然后先做解密处理，再做数字签名的认证， 如果这两步都失败，说明这个登录凭证非法；如果这两步成功，接着就可以拿到原始存入的登录凭证了。然后用这个凭证的过期时间和当前时间做对比， 判断凭证是否过期，如果过期，就需要用户再重新登录；如果未过期，则允许请求继续。它的缺点也比较明显： cookie有大小限制，存储不了太多数据 每次传送cookie，增加了请求的数量，对访问性能也有影响； 也有跨域问题，毕竟还是要用cookie。也有跨域问题，毕竟还是要用cookie。跨域的问题可以用CORS（跨域资源共享）的方式来快速解决。基于token前面两种会话管理方式因为都用到cookie，不适合用在移动端native app里面，native app不好管理cookie，毕竟它不是浏览器。 这两种方案都不适合用来做纯api服务的登录认证，就要考虑第三种会话管理方式，也就是token认证。这种方式从流程和实现上来说，跟cookie-based的方式没有太多区别，只不过cookie-based里面写到cookie里面的ticket在这种方式下称为token， 这个token在返回给客户端之后，后续请求都必须通过url参数或者是http header的形式，主动带上token， 这样服务端接收到请求之后就能直接从http header或者url里面取到token进行验证：这种方式不通过cookie进行token的传递，而是每次请求的时候，主动把token加到http header里面或者url后面， 所以即使在native app里面也能使用它来调用我们通过web发布的api接口。app里面还要做两件事情： 有效存储token，得保证每次调接口的时候都能从同一个位置拿到同一个token； 每次调接口的的代码里都得把token加到header或者接口地址里面。这种方式同样适用于网页应用，token可以存于localStorage或者sessionStorage里面，然后每发ajax请求的时候， 都把token拿出来放到ajax请求的header里即可。不过如果是非接口的请求，比如直接通过点击链接请求一个页面这种， 是无法自动带上token的。所以这种方式也仅限于走纯接口的web应用。JWT现在SPA应用，前后端完全分离，基于API接口的应用越来越多，这时候基于token的认证就是最好的选择方式了。 好在这个方式的技术其实早就有很多实现了，而且还有现成的标准可用，这个标准就是JWT(json-web-token)。JWT本身并没有做任何技术实现，它只是定义了token-based的管理方式该如何实现， 它规定了token的应该包含的标准内容以及token的生成过程和方法。目前实现了这个标准的技术已经有非常多。官方网站：[1]: https://jwt.io/#libraries-io]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>会话管理</tag>
      </tags>
  </entry>
</search>
