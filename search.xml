<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vim简明教程]]></title>
    <url>%2F2018%2F03%2F30%2Fvim%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vim 是 Linux 系统上的最著名的文本/代码编辑器，也是早年的 Vi 编辑器的加强版， 而 gvim 则是其 Windows 版。它的最大特色是完全使用键盘命令进行编辑，脱离了鼠标操作虽然使得入门变得困难， 但上手之后键盘流的各种巧妙组合操作却能带来极为大幅的效率提升。 因此 vim 和现代的编辑器（如 Sublime Text）有着非常巨大的差异，而且入门学习曲线陡峭， 需要记住很多按键组合和命令，如今被看作是高手、Geek们专用的编辑器。尽管 vim 已经是古董级的软件， 但还是有无数新人迎着困难去学习使用，可见其经典与受欢迎程度。另外，由于 vim 的可配置性非常强， 各种插件、语法高亮配色方案等多不胜数，无论作为代码编辑器或是文稿撰写工具都非常给力。 安装以ubuntu为例：1sudo apt-get install vim 配置vim本身能够满足开发人员的很多需求，但是它的扩展性也是极强的，并且已经有一些杀手级的扩展，可以让vim有变成ide的能力，所以，你所需要的第一件东西就是一个好用的扩展管理器。 vim有多个扩展管理器，但是我们强烈推荐vundle。 我们先安装Vundle:1git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim 该命令下载的Vundle插件管理器，并将它放置在你的vim编辑器bundles文件夹中。现在，你可以通过.vimrc配置文件来管理所有扩展了。 我在这里有一个比较优化的配置，将vim打造成一个IDE，编辑~/.vimrc,输入如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151"vundleset nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'"git interfacePlugin 'tpope/vim-fugitive'"filesystemPlugin 'scrooloose/nerdtree'Plugin 'jistr/vim-nerdtree-tabs'Plugin 'kien/ctrlp.vim'"html" isnowfy only compatible with python not python3Plugin 'isnowfy/python-vim-instant-markdown'Plugin 'jtratner/vim-flavored-markdown'Plugin 'suan/vim-instant-markdown'Plugin 'nelstrom/vim-markdown-preview'"python sytax checkerPlugin 'nvie/vim-flake8'Plugin 'vim-scripts/Pydiction'Plugin 'vim-scripts/indentpython.vim'Plugin 'scrooloose/syntastic'"auto-completion stuff"Plugin 'klen/python-mode'Plugin 'Valloric/YouCompleteMe'Plugin 'klen/rope-vim'"Plugin 'davidhalter/jedi-vim'Plugin 'ervandew/supertab'""code foldingPlugin 'tmhedberg/SimpylFold'"Colors!!!Plugin 'altercation/vim-colors-solarized'Plugin 'jnurmine/Zenburn'call vundle#end()filetype plugin indent on " enables filetype detectionlet g:SimpylFold_docstring_preview = 1"autocompletelet g:ycm_autoclose_preview_window_after_completion=1"custom keyslet mapleader=" "map &lt;leader&gt;g :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;"call togglebg#map("&lt;F5&gt;")"colorscheme zenburn"set guifont=Monaco:h14let NERDTreeIgnore=['\.pyc$', '\~$'] "ignore files in NERDTree"I don't like swap filesset noswapfile"turn on numberingset nu"python with virtualenv supportpy &lt;&lt; EOFimport os.pathimport sysimport vimif 'VIRTUA_ENV' in os.environ: project_base_dir = os.environ['VIRTUAL_ENV'] sys.path.insert(0, project_base_dir) activate_this = os.path.join(project_base_dir,'bin/activate_this.py') execfile(activate_this, dict(__file__=activate_this))EOF"it would be nice to set tag files by the active virtualenv here":set tags=~/mytags "tags for ctags and taglist"omnicompleteautocmd FileType python set omnifunc=pythoncomplete#Complete"------------Start Python PEP 8 stuff----------------" Number of spaces that a pre-existing tab is equal to.au BufRead,BufNewFile *py,*pyw,*.c,*.h set tabstop=4"spaces for indentsau BufRead,BufNewFile *.py,*pyw set shiftwidth=4au BufRead,BufNewFile *.py,*.pyw set expandtabau BufRead,BufNewFile *.py set softtabstop=4" Use the below highlight group when displaying bad whitespace is desired.highlight BadWhitespace ctermbg=red guibg=red" Display tabs at the beginning of a line in Python mode as bad.au BufRead,BufNewFile *.py,*.pyw match BadWhitespace /^\t\+/" Make trailing whitespace be flagged as bad.au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/" Wrap text after a certain number of charactersau BufRead,BufNewFile *.py,*.pyw, set textwidth=100" Use UNIX (\n) line endings.au BufNewFile *.py,*.pyw,*.c,*.h set fileformat=unix" Set the default file encoding to UTF-8:set encoding=utf-8" For full syntax highlighting:let python_highlight_all=1syntax on" Keep indentation level from previous line:autocmd FileType python set autoindent" make backspaces more powerfullset backspace=indent,eol,start"Folding based on indentation:autocmd FileType python set foldmethod=indent"use space to open foldsnnoremap &lt;space&gt; za"----------Stop python PEP 8 stuff--------------"js stuff"autocmd FileType javascript setlocal shiftwidth=2 tabstop=2syntax on "语法高亮显示。set encoding=utf-8set hlsearch "高亮度反白set backspace=2 "可以用Backspace键删除set ts=4 "tab键等于4个空格set expandtab "tab键自动变空格set tabstop=4set softtabstop=4set autoindent "自动缩进set pastetoggle=&lt;F9&gt; "插入模式粘贴按F9取消自动缩进set ruler "可显示最后一行的状态set showmode "左下角那一行的状态set nu "可以在每一行的最前面显示行号啦！set bg=dark "显示不同的底色色调"set cursorline "光标所在行一横线set laststatus=2 "显示当前编辑文件名set showcmdset magicset lazyredrawset history=100 "历史记录条数set hlsearch "高亮显示搜索结果set incsearch "增量搜索，每次输入一个字母都自动搜"choose and replacevnoremap ,s y:%s/&lt;C-R&gt;=escape(@", '\\/.*$^~[]')&lt;CR&gt;/ PS:把配置写进去后，要在vim里面执行:PluginInstall命令来让Vundle自动帮你安装所有插件。 问题记录出现过问题”ouCompleteMe unavaliable:No module named ycmd” 解决办法：123cd ~/.vim/bundle/YouCompleteMegit pullgit submodule update --init --recursive 但是在执行过程中报错：The remote end hung up unexpectedly,这是因为网络不稳定，要下载的东西很多试几次，耐心一点就可以了。 The ycmd server SHUT DOWN (restart with ‘YcmRestartServer’)YCM需要手动变异才行，到.vim/bundle/YouCompleteMe下跑1./install.sh --clang-completer 此过程速度较慢，请耐心等待下买呢是我配置完成过后的vim： 入门vim 有三种模式：1: 一般模式：在linux终端输入”vim文件名”就进入了一般模式，但不能输入文字。2: 编辑模式：在一般模式下按i就会进入编辑模式，此时就可以写文字了，按ESC可以回退到一般模式。3: 命令模式： 在一般模式下按:就会进入命令模式，左下角会有一个冒号出现，此时可以敲入命令并执行。当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作： 启动vim后，vim在normal模式下。 让我们进入insert模式，请按i。（vim左下角有一个insert字样，表示你可以输入了） 此时，你可以输入文本了吗，就像你用记事本一样。 如果你想返回normal模式，请按ESC键现在，你知道如果在insert和normal模式下切换了。下面是一些命令，可以让你在normal模式下幸存下来：12345i -&gt; Insert模式，按ESC回到Normal模式。x -&gt; 删除当前光标所在的一个字符。:wq -&gt; 存盘 + 退出（w:存盘，q：退出）dd -&gt; 删除当前行，并把当前行存到剪切板里。p -&gt; 粘贴剪切板 推荐12hjkl(强烈推荐使用这几个键移动光标，但不必须) 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。:help &lt;command&gt; 显示相关命令的帮助。 进阶1现在是时候学习一些更多的命令了，下面是我的建议： 各种插入模式1234a → 在光标后插入o → 在当前行后插入一个新行O → 在当前行前插入一个新行cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标12340 → 数字零，到行头$ → 到本行行尾g_ → 到本行最后一个不是blank字符的位置。/pattern → 搜索 pattern 的字符串 拷贝/粘贴(p/P都可以，p是表示在当前位置之后，P表示在当前位置之前)12P → 粘贴yy → 拷贝当前行当行于 ddP Undo/Redo12u → undo&lt;C-r&gt; → redo 打开/保存/退出/改变文件(Buffer)123456:e &lt;path/to/file&gt; → 打开一个文件:w → 存盘:saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt;:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车):q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么说ArrayList线程不安全]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[概要介绍所谓线程安全，指多个线程同时操作同一个对象的时候，采用了加锁机制，当第一个线程在操作这个对象的时候，后面将要操作该对象的线程都得等第一个对象操作完成再执行，这样就能保证数据的完整性。 举例：List接口下面有两个，一个是ArrayList,一个是Vector。从源码的角度来分析，因为Vector的方法前加了，synchronized 关键字，也就是同步的意思，sun公司希望Vector是线程安全的，而希望arraylist是高效的，缺点就是另外的优点。 说下原理（百度的，很好理解）： 一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：1:在Item[size]的位置存放该元素;2:增大size的值。在单线程运行的情况下，如果size=0,添加一个元素后，此元素位置在0，size=1;而如果是多线程的情况下；比如有两个线程，线程A先将元素存放在位置0，但是此时CPU的调度线程A暂停，线程B就有了运行的机会，线程B向此ArrayList中添加元素，此时size依然等于0，(我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1),所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。下面为我们写段代码来验证123456789101112131415161718192021222324252627282930final List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0;i &lt; 10000;i++)&#123; list.add(i);&#125;System.out.println("第一次添加完成后list的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.remove(0); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("移除完成后List的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.add(j*10); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("第二次添加完成后List的数量："+list.size()); 输出的结果是：123第一次添加完成后list的数量：10000移除完成后List的数量：393第二次添加完成后List的数量：9319 而我们期望的结果是：123第一次添加完成后list的数量：10000移除完成后List的数量：0第二次添加完成后List的数量：10000 这就是因为ArrayList没有加同步锁导致的，下面再来一段Vector的代码：123456789101112131415161718192021222324252627282930final List&lt;Integer&gt; list = new Vector&lt;&gt;();for (int i = 0;i &lt; 10000;i++)&#123; list.add(i);&#125;System.out.println("第一次添加完成后list的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.remove(0); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("移除完成后List的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.add(j*10); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("第二次添加完成后List的数量："+list.size()); 输出结果：123第一次添加完成后list的数量：10000移除完成后List的数量：0第二次添加完成后List的数量：10000]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
