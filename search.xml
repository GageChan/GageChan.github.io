<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F04%2F02%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言想要分析下源码是好事，但是如何进行分析呢？以我为例，我进行源码分析的过程如下几步： 找到类：利用IDEA找到所需要分析的类（这里就是ArrayList） 新建类：新建一个类，命名为ArrayList,将源码拷贝到该类中。因为我们在分析的过程中肯定是需要对代码进行注释和调试的，而对jdk的源码，我们没法儿在里面直接写注释以及调试的。 按照上面的方法将新建AbstractList类，并将源码拷贝过来，这是由于ArrayList中要用到AbstractList类中的变量，如果不拷贝过来就会报错。 修改类：我们刚拷贝过来的源码，肯定会报错的。报错原因比如：包名不匹配、继承的类中权限问题，因此我们需要对源码进行修改 查看代码 + 测试案例 + 断点调试：前面准备好了，就到分析的过程了。分析，不仅仅是简单的看下代码，我们需要仔细思考，且辅以相应的测试案例，甚至于进行断点跟踪查看运行过程。下面我们就对jdk1.8的源码进行分析。 ArrayList简介ArrayList概述1: ArrayList是可以动态增加和缩减的，踏实数组实现的list类。2: 该类封装了一个动态再分配的Object[]数组，每一个类对象都有一个capacity属性，表示他们所封装的数组的长度，当向ArrayList中添加数据的时候，capacity会自动增长，如果想ArrayList中添加大量元素，可使用ensureCapacity方法一次性增加capacity，可以减少增加重分配的次数提高性能。3: ArrayList的用法和Vector向类似，但是Vector是一个较老的集合，具有很多缺点，不建议使用。另外，ArrayList和Vector的区别是：ArrayList是线程不安全的，当多条线程访问同一个ArrayList集合时，程序需要手动保证该集合的同步性，而Vector则是线程安全的。 ArrayList的数据结构分析一个类的时候，数据结构往往是它的灵魂所在，理解底层的数据结构其实就是理解该类的思路。ArrayList的数据结构是：PS：底层的数据结构就是数组，数组元素类型为Object类型，即可以存放所有类型数据。我们对ArrayList类的实例的所有的操作底层都是基于数组的。 ArrayList源码分析继承结构和层次关系分析：1: 为什么要先继承AbstractList，而让AbstractList先实现List？而不是让ArrayList直接实现List？这里是有一个思想，接口中全都是抽象的方法，而抽象类中可以有抽象方法，还可以有具体的实现方法，正是利用了这一点，让AbstractList是实现接口中一些通用的方法，而具体的类，如ArrayList就继承这个AbstractList类，拿到一些通用的方法，然后自己在实现一些自己特有的方法，这样一来，让代码更简洁，就继承结构最底层的类中通用的方法都抽取出来，先一起实现了，减少重复代码。所以一般看到一个类上面还有一个抽象类，应该就是这个作用。2: ArrayList实现了哪些接口？ List接口：我们会出现这样一个疑问，在查看了ArrayList的父类AbstractList也实现了List接口，那为什么子类ArrayList还是去实现一遍呢？开发这个collection 的作者Josh说：这其实是一个mistake，因为他写这代码的时候觉得这个会有用处，但是其实并没什么用，但因为没什么影响，就一直留到了现在。 RandomAccess接口：这个是一个标记性接口，通过查看api文档，它的作用就是用来快速随机存取，有关效率的问题，在实现了该接口的话，那么使用普通的for循环来遍历，性能更高，例如arrayList。而没有实现该接口的话，使用Iterator来迭代，这样性能更高，例如linkedList。所以这个标记性只是为了让我们知道我们用什么样的方式去获取数据性能更好。 Cloneable接口：实现了该接口，就可以使用Object.Clone()方法了。 Serializable接口：实现该序列化接口，表明该类可以被序列化，什么是序列化？简单的说，就是能够从类变成字节流传输，然后还能从字节流变成原来的类。类中的属性123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 版本号 private static final long serialVersionUID = 8683452581122892189L; // 缺省容量 private static final int DEFAULT_CAPACITY = 10; // 空对象数组 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; // 缺省空对象数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; // 元素数组 transient Object[] elementData; // 实际元素大小，默认为0 private int size; // 最大数组容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;&#125; 构造方法ArrayList有三个构造方法：1: 无参构造方法12345678/*** 这里就说明了默认会给10的大小，所以说一开始arrayList的容量是10.*///ArrayList中储存数据的其实就是一个数组，这个数组就是elementData，在123行定义的 private transient Object[] elementData; public ArrayList() &#123; super(); //调用父类中的无参构造方法，父类中的是个空的构造方法 this.elementData = EMPTY_ELEMENTDATA;//EMPTY_ELEMENTDATA：是个空的Object[]， 将elementData初始化，elementData也是个Object[]类型。空的Object[]会给默认大小10，等会会解释什么时候赋值的。&#125; 2: 有参构造方法(一)1234567public ArrayList(int initialCapacity) &#123; super(); //父类中空的构造方法 if (initialCapacity &lt; 0)&#123; //判断如果自定义大小的容量小于0，则报下面这个非法数据异常 throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity); this.elementData = new Object[initialCapacity]; //将自定义的容量大小当成初始化elementData的大小 &#125;&#125; 3: 有参构造方法(二)123456789101112//这个构造方法不常用，举个例子就能明白什么意思/* Strudent exends Person ArrayList&lt;Person&gt;、 Person这里就是泛型 我还有一个Collection&lt;Student&gt;、由于这个Student继承了Person，那么根据这个构造方法，我就可以把这个Collection&lt;Student&gt;转换为ArrayList&lt;Sudent&gt;这就是这个构造方法的作用 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); //转换为数组 size = elementData.length; //数组中的数据个数 if (elementData.getClass() != Object[].class) //每个集合的toarray()的实现方法不一样，所以需要判断一下，如果不是Object[].class类型，那么久需要使用ArrayList中的方法去改造一下。 elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 总结：arrayList的构造方法就做一件事情，就是初始化一下储存数据的容器，其实本质上就是一个数组，在其中就叫elementData。 核心方法 add()方法（有四个） 1: boolean add(E)//默认直接在末尾添加元素12345678910/*** 添加一个特定的元素到list的末尾。*/public boolean add(E e) &#123; //确定内部容量是否够了，size是数组中数据的个数，因为要添加一个元素，所以size+1，先判断size+1的这个个数数组能否放得下，就在这个方法中去判断是否数组.length是否够用了。 ensureCapacityInternal(size + 1); // Increments modCount!! //在数据中正确的位置上放上元素e，并且size++ elementData[size++] = e; return true;&#125; 分析：ensureCapacityInternal(xxx); 确定内部容量的方法 12345678private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; //看，判断初始化的elementData是不是空的数组，也就是没有长度 //因为如果是空的话，minCapacity=size+1；其实就是等于1，空的数组没有长度就存放不了，所以就将minCapacity变成10，也就是默认大小，但是带这里，还没有真正的初始化这个elementData的大小。 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //确认实际的容量，上面只是将minCapacity=10，这个方法就是真正的判断elementData是否够用 ensureExplicitCapacity(minCapacity);&#125; ensureExplicitCapacity(xxx);123456789101112private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;/*minCapacity如果大于了实际elementData的长度，那么就说明elementData数组的长度不够用，不够用那么就要增加elementData的length。这里有的同学就会模糊minCapacity到底是什么呢，这里给你们分析一下第一种情况：由于elementData初始化时是空的数组，那么第一次add的时候，minCapacity=size+1；也就minCapacity=1，在上一个方法(确定内部容量ensureCapacityInternal)就会判断出是空的数组，就会给将minCapacity=10，到这一步为止，还没有改变elementData的大小。第二种情况：elementData不是空的数组了，那么在add的时候，minCapacity=size+1；也就是minCapacity代表着elementData中增加之后的实际数据个数，拿着它判断elementData的length是否够用，如果length不够用，那么肯定要扩大容量，不然增加的这个元素就会溢出。*/ if (minCapacity - elementData.length &gt; 0) //arrayList能自动扩展大小的关键方法就在这里了 grow(minCapacity);&#125; grow(xxx);arrayList核心的方法，能扩展数组大小的真正秘密。12345678910private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //将扩充前的elementData大小给oldCapacity int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//newCapacity就是1.5倍的oldCapacity if (newCapacity - minCapacity &lt; 0)//这句话就是适应于elementData就空数组的时候，length=0，那么oldCapacity=0，newCapacity=0，所以这个判断成立，在这里就是真正的初始化elementData的大小了，就是为10.前面的工作都是准备工作。 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//如果newCapacity超过了最大的容量限制，就调用hugeCapacity，也就是将能给的最大值给newCapacity newCapacity = hugeCapacity(minCapacity); //新的容量大小已经确定好了，就copy数组，改变容量大小咯。 elementData = Arrays.copyOf(elementData, newCapacity); &#125; hugeCapacity();12345678//这个就是上面用到的方法，很简单，就是用来赋最大值。 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //如果minCapacity都大于MAX_ARRAY_SIZE，那么就Integer.MAX_VALUE返回，反之将MAX_ARRAY_SIZE返回。因为maxCapacity是三倍的minCapacity，可能扩充的太大了，就用minCapacity来判断了。 //Integer.MAX_VALUE:2147483647 MAX_ARRAY_SIZE：2147483639 也就是说最大也就能给到第一个数值。还是超过了这个限制，就要溢出了。相当于arraylist给了两层防护。 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE :MAX_ARRAY_SIZE;&#125; 2: void add(int，E)；在特定位置添加元素，也就是插入元素12345678910public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index也就是插入的位置是否合理。 //跟上面的分析一样，具体看上面 ensureCapacityInternal(size + 1); //这个方法就是用来在插入元素之后，要将index之后的元素都往后移一位， System.arraycopy(elementData, index, elementData, index + 1,size - index); //在目标位置上存放元素 elementData[index] = element; size++;//size增加1&#125; rangeCheckForAdd(index)1234private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) //插入的位置肯定不能大于size 和小于0,如果是，就报这个越界异常 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; System.arraycopy(…)：就是将elementData在插入位置后的所有元素往后面移一位。 删除方法1: remove(int)：通过删除指定位置上的元素12345678910111213public E remove(int index) &#123; rangeCheck(index);//检查index的合理性 modCount++;//这个作用很多，比如用来检测快速失败的一种标志。 E oldValue = elementData(index);//通过索引直接找到该元素 int numMoved = size - index - 1;//计算要移动的位数。 if (numMoved &gt; 0) //这个方法也已经解释过了，就是用来移动元素的。 System.arraycopy(elementData, index+1, elementData, index,numMoved); //将--size上的位置赋值为null，让gc(垃圾回收机制)更快的回收它。 elementData[--size] = null; // clear to let GC do its work //返回删除的元素。 return oldValue;&#125; 2: clear()：将elementData中每个元素都赋值为null，等待垃圾回收将这个给回收掉，所以叫clear。1234567public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 总结：remove函数用户移除指定下标的元素，此时会把指定下标到数组末尾的元素向前移动一个单位，并且会把数组最后一个元素设置为null，这样是为了方便之后将整个数组不被使用时，会被GC，可以作为小的技巧使用。 set()方法12345678910public E set(int index, E element) &#123; // 检验索引是否合法 rangeCheck(index); // 旧值 E oldValue = elementData(index); // 赋新值 elementData[index] = element; // 返回旧值 return oldValue;&#125; PS:设定指定下标索引的元素值 indexOf()方法1234567891011121314// 从首开始查找数组里面是否存在指定元素public int indexOf(Object o) &#123; if (o == null) &#123; // 查找的元素为空 for (int i = 0; i &lt; size; i++) // 遍历数组，找到第一个为空的元素，返回下标 if (elementData[i]==null) return i; &#125; else &#123; // 查找的元素不为空 for (int i = 0; i &lt; size; i++) // 遍历数组，找到第一个和指定元素相等的元素，返回下标 if (o.equals(elementData[i])) return i; &#125; // 没有找到，返回空 return -1;&#125; PS:从头开始查找与指定元素相等的元素，注意，是可以查找null元素的，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找 get()方法12345public E get(int index) &#123; // 检验索引是否合法 rangeCheck(index); return elementData(index);&#125; PS:get函数会检查索引值是否合法（只检查是否大于size，而没有检查是否小于0），值得注意的是，在get函数中存在element函数，element函数用于返回具体的元素，具体函数如下：123E elementData(int index) &#123; return (E) elementData[index];&#125; PS:返回的值都经过了向下转型（Object -&gt; E），这些是对我们应用程序屏蔽的小细节。 总结 arrayList可以存放null。 arrayList本质上就是一个elementData数组。 arrayList区别于数组的地方在于能够自动扩展大小，其中关键的方法就是gorw()方法。 arrayList中removeAll(collection c)和clear()的区别就是removeAll可以删除批量指定的元素，而clear是全是删除集合中的元素。 arrayList由于本质是数组，所以它在数据的查询方面会很快，而在插入删除这些方面，性能下降很多，有移动很多数据才能达到应有的效果 arrayList实现了RandomAccess，所以在遍历它的时候推荐使用for循环。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim简明教程]]></title>
    <url>%2F2018%2F03%2F28%2Fvim%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[vim 是 Linux 系统上的最著名的文本/代码编辑器，也是早年的 Vi 编辑器的加强版， 而 gvim 则是其 Windows 版。它的最大特色是完全使用键盘命令进行编辑，脱离了鼠标操作虽然使得入门变得困难， 但上手之后键盘流的各种巧妙组合操作却能带来极为大幅的效率提升。 因此 vim 和现代的编辑器（如 Sublime Text）有着非常巨大的差异，而且入门学习曲线陡峭， 需要记住很多按键组合和命令，如今被看作是高手、Geek们专用的编辑器。尽管 vim 已经是古董级的软件， 但还是有无数新人迎着困难去学习使用，可见其经典与受欢迎程度。另外，由于 vim 的可配置性非常强， 各种插件、语法高亮配色方案等多不胜数，无论作为代码编辑器或是文稿撰写工具都非常给力。 安装以ubuntu为例：1sudo apt-get install vim 配置vim本身能够满足开发人员的很多需求，但是它的扩展性也是极强的，并且已经有一些杀手级的扩展，可以让vim有变成ide的能力，所以，你所需要的第一件东西就是一个好用的扩展管理器。 vim有多个扩展管理器，但是我们强烈推荐vundle。 我们先安装Vundle:1git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim 该命令下载的Vundle插件管理器，并将它放置在你的vim编辑器bundles文件夹中。现在，你可以通过.vimrc配置文件来管理所有扩展了。 我在这里有一个比较优化的配置，将vim打造成一个IDE，编辑~/.vimrc,输入如下内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151"vundleset nocompatiblefiletype offset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()Plugin 'VundleVim/Vundle.vim'"git interfacePlugin 'tpope/vim-fugitive'"filesystemPlugin 'scrooloose/nerdtree'Plugin 'jistr/vim-nerdtree-tabs'Plugin 'kien/ctrlp.vim'"html" isnowfy only compatible with python not python3Plugin 'isnowfy/python-vim-instant-markdown'Plugin 'jtratner/vim-flavored-markdown'Plugin 'suan/vim-instant-markdown'Plugin 'nelstrom/vim-markdown-preview'"python sytax checkerPlugin 'nvie/vim-flake8'Plugin 'vim-scripts/Pydiction'Plugin 'vim-scripts/indentpython.vim'Plugin 'scrooloose/syntastic'"auto-completion stuff"Plugin 'klen/python-mode'Plugin 'Valloric/YouCompleteMe'Plugin 'klen/rope-vim'"Plugin 'davidhalter/jedi-vim'Plugin 'ervandew/supertab'""code foldingPlugin 'tmhedberg/SimpylFold'"Colors!!!Plugin 'altercation/vim-colors-solarized'Plugin 'jnurmine/Zenburn'call vundle#end()filetype plugin indent on " enables filetype detectionlet g:SimpylFold_docstring_preview = 1"autocompletelet g:ycm_autoclose_preview_window_after_completion=1"custom keyslet mapleader=" "map &lt;leader&gt;g :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;"call togglebg#map("&lt;F5&gt;")"colorscheme zenburn"set guifont=Monaco:h14let NERDTreeIgnore=['\.pyc$', '\~$'] "ignore files in NERDTree"I don't like swap filesset noswapfile"turn on numberingset nu"python with virtualenv supportpy &lt;&lt; EOFimport os.pathimport sysimport vimif 'VIRTUA_ENV' in os.environ: project_base_dir = os.environ['VIRTUAL_ENV'] sys.path.insert(0, project_base_dir) activate_this = os.path.join(project_base_dir,'bin/activate_this.py') execfile(activate_this, dict(__file__=activate_this))EOF"it would be nice to set tag files by the active virtualenv here":set tags=~/mytags "tags for ctags and taglist"omnicompleteautocmd FileType python set omnifunc=pythoncomplete#Complete"------------Start Python PEP 8 stuff----------------" Number of spaces that a pre-existing tab is equal to.au BufRead,BufNewFile *py,*pyw,*.c,*.h set tabstop=4"spaces for indentsau BufRead,BufNewFile *.py,*pyw set shiftwidth=4au BufRead,BufNewFile *.py,*.pyw set expandtabau BufRead,BufNewFile *.py set softtabstop=4" Use the below highlight group when displaying bad whitespace is desired.highlight BadWhitespace ctermbg=red guibg=red" Display tabs at the beginning of a line in Python mode as bad.au BufRead,BufNewFile *.py,*.pyw match BadWhitespace /^\t\+/" Make trailing whitespace be flagged as bad.au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/" Wrap text after a certain number of charactersau BufRead,BufNewFile *.py,*.pyw, set textwidth=100" Use UNIX (\n) line endings.au BufNewFile *.py,*.pyw,*.c,*.h set fileformat=unix" Set the default file encoding to UTF-8:set encoding=utf-8" For full syntax highlighting:let python_highlight_all=1syntax on" Keep indentation level from previous line:autocmd FileType python set autoindent" make backspaces more powerfullset backspace=indent,eol,start"Folding based on indentation:autocmd FileType python set foldmethod=indent"use space to open foldsnnoremap &lt;space&gt; za"----------Stop python PEP 8 stuff--------------"js stuff"autocmd FileType javascript setlocal shiftwidth=2 tabstop=2syntax on "语法高亮显示。set encoding=utf-8set hlsearch "高亮度反白set backspace=2 "可以用Backspace键删除set ts=4 "tab键等于4个空格set expandtab "tab键自动变空格set tabstop=4set softtabstop=4set autoindent "自动缩进set pastetoggle=&lt;F9&gt; "插入模式粘贴按F9取消自动缩进set ruler "可显示最后一行的状态set showmode "左下角那一行的状态set nu "可以在每一行的最前面显示行号啦！set bg=dark "显示不同的底色色调"set cursorline "光标所在行一横线set laststatus=2 "显示当前编辑文件名set showcmdset magicset lazyredrawset history=100 "历史记录条数set hlsearch "高亮显示搜索结果set incsearch "增量搜索，每次输入一个字母都自动搜"choose and replacevnoremap ,s y:%s/&lt;C-R&gt;=escape(@", '\\/.*$^~[]')&lt;CR&gt;/ PS:把配置写进去后，要在vim里面执行:PluginInstall命令来让Vundle自动帮你安装所有插件。 问题记录出现过问题”ouCompleteMe unavaliable:No module named ycmd” 解决办法：123cd ~/.vim/bundle/YouCompleteMegit pullgit submodule update --init --recursive 但是在执行过程中报错：The remote end hung up unexpectedly,这是因为网络不稳定，要下载的东西很多试几次，耐心一点就可以了。 The ycmd server SHUT DOWN (restart with ‘YcmRestartServer’)YCM需要手动变异才行，到.vim/bundle/YouCompleteMe下跑1./install.sh --clang-completer 此过程速度较慢，请耐心等待下买呢是我配置完成过后的vim： 入门vim 有三种模式：1: 一般模式：在linux终端输入”vim文件名”就进入了一般模式，但不能输入文字。2: 编辑模式：在一般模式下按i就会进入编辑模式，此时就可以写文字了，按ESC可以回退到一般模式。3: 命令模式： 在一般模式下按:就会进入命令模式，左下角会有一个冒号出现，此时可以敲入命令并执行。当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作： 启动vim后，vim在normal模式下。 让我们进入insert模式，请按i。（vim左下角有一个insert字样，表示你可以输入了） 此时，你可以输入文本了吗，就像你用记事本一样。 如果你想返回normal模式，请按ESC键现在，你知道如果在insert和normal模式下切换了。下面是一些命令，可以让你在normal模式下幸存下来：12345i -&gt; Insert模式，按ESC回到Normal模式。x -&gt; 删除当前光标所在的一个字符。:wq -&gt; 存盘 + 退出（w:存盘，q：退出）dd -&gt; 删除当前行，并把当前行存到剪切板里。p -&gt; 粘贴剪切板 推荐12hjkl(强烈推荐使用这几个键移动光标，但不必须) 你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。:help &lt;command&gt; 显示相关命令的帮助。 进阶1现在是时候学习一些更多的命令了，下面是我的建议： 各种插入模式1234a → 在光标后插入o → 在当前行后插入一个新行O → 在当前行前插入一个新行cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标12340 → 数字零，到行头$ → 到本行行尾g_ → 到本行最后一个不是blank字符的位置。/pattern → 搜索 pattern 的字符串 拷贝/粘贴(p/P都可以，p是表示在当前位置之后，P表示在当前位置之前)12P → 粘贴yy → 拷贝当前行当行于 ddP Undo/Redo12u → undo&lt;C-r&gt; → redo 打开/保存/退出/改变文件(Buffer)123456:e &lt;path/to/file&gt; → 打开一个文件:w → 存盘:saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt;:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车):q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么说ArrayList线程不安全]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[概要介绍所谓线程安全，指多个线程同时操作同一个对象的时候，采用了加锁机制，当第一个线程在操作这个对象的时候，后面将要操作该对象的线程都得等第一个对象操作完成再执行，这样就能保证数据的完整性。 举例：List接口下面有两个，一个是ArrayList,一个是Vector。从源码的角度来分析，因为Vector的方法前加了，synchronized 关键字，也就是同步的意思，sun公司希望Vector是线程安全的，而希望arraylist是高效的，缺点就是另外的优点。 说下原理（百度的，很好理解）： 一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：1:在Item[size]的位置存放该元素;2:增大size的值。在单线程运行的情况下，如果size=0,添加一个元素后，此元素位置在0，size=1;而如果是多线程的情况下；比如有两个线程，线程A先将元素存放在位置0，但是此时CPU的调度线程A暂停，线程B就有了运行的机会，线程B向此ArrayList中添加元素，此时size依然等于0，(我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1),所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。下面为我们写段代码来验证123456789101112131415161718192021222324252627282930final List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0;i &lt; 10000;i++)&#123; list.add(i);&#125;System.out.println("第一次添加完成后list的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.remove(0); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("移除完成后List的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.add(j*10); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("第二次添加完成后List的数量："+list.size()); 输出的结果是：123第一次添加完成后list的数量：10000移除完成后List的数量：393第二次添加完成后List的数量：9319 而我们期望的结果是：123第一次添加完成后list的数量：10000移除完成后List的数量：0第二次添加完成后List的数量：10000 这就是因为ArrayList没有加同步锁导致的，下面再来一段Vector的代码：123456789101112131415161718192021222324252627282930final List&lt;Integer&gt; list = new Vector&lt;&gt;();for (int i = 0;i &lt; 10000;i++)&#123; list.add(i);&#125;System.out.println("第一次添加完成后list的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.remove(0); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("移除完成后List的数量："+list.size());for (int i = 0;i &lt; 10;i++)&#123; new Thread()&#123; @Override public void run() &#123; for (int j = 0;j &lt; 1000;j++)&#123; list.add(j*10); &#125; &#125; &#125;.start();&#125;Thread.sleep(10000);System.out.println("第二次添加完成后List的数量："+list.size()); 输出结果：123第一次添加完成后list的数量：10000移除完成后List的数量：0第二次添加完成后List的数量：10000]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
